#!/usr/bin/env python3
"""Generate a Markdown secrets detection report from Gitleaks JSON output.

This script is used both locally (via 'task secrets') and in CI/CD.
It must reliably generate reports without silently hiding errors.
"""

import json
import os
import sys
import traceback
from datetime import datetime


def read_json_report(json_path):
    """Read Gitleaks JSON report and return findings."""
    if not os.path.exists(json_path):
        raise FileNotFoundError(f"Secrets JSON report not found at {json_path}")

    try:
        with open(json_path, "r") as f:
            content = f.read().strip()
        # Gitleaks writes "null" when no secrets are found
        if not content or content == "null":
            return []
        data = json.loads(content)
        # Gitleaks outputs a list of findings
        return data if isinstance(data, list) else []
    except Exception as e:
        raise RuntimeError(f"Failed to read secrets JSON report: {e}") from e


def format_finding_row(finding):
    """Format a single finding as a markdown table row."""
    rule_id = finding.get("RuleID", finding.get("ruleID", "unknown"))
    description = finding.get("Description", finding.get("description", ""))
    file_path = finding.get("File", finding.get("file", "unknown"))
    line = finding.get("StartLine", finding.get("startLine", "?"))
    commit = finding.get("Commit", finding.get("commit", ""))
    short_commit = commit[:8] if commit else "working tree"
    location = f"`{file_path}:{line}`"
    desc_truncated = (description[:57] + "...") if len(description) > 60 else description
    return f"| {rule_id} | {location} | {short_commit} | {desc_truncated} |"


def build_markdown_report(findings):
    """Build the complete markdown report from Gitleaks JSON output."""
    total = len(findings)

    md_content = "# Secrets Detection Report\n\n"
    md_content += f"**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    md_content += "## Summary\n\n"

    if total == 0:
        md_content += "## ✅ Secrets Status\n\nNo secrets detected.\n\n"
    else:
        md_content += f"> ⚠️ **{total} secret(s) detected** — revoke and remove immediately.\n\n"
        md_content += "| Rule | Location | Commit | Description |\n"
        md_content += "|------|----------|--------|-------------|\n"
        for finding in findings:
            md_content += format_finding_row(finding) + "\n"
        md_content += "\n"

    md_content += "## Guidelines\n\n"
    md_content += "- **If secrets are found**: Revoke the credential immediately, then remove it from the codebase and git history\n"
    md_content += "- Use environment variables or a secrets manager instead of hardcoding credentials\n"
    md_content += "- Consider adding a `.gitleaks.toml` to tune rules for your project\n"
    md_content += "- Run `task secrets` locally before pushing to catch issues early\n\n"
    md_content += "## More Information\n\n"
    md_content += "- Generated by [Gitleaks](https://gitleaks.io/)\n"
    md_content += "- Reports location: `.secrets-reports/`\n"
    md_content += "  - `secrets-report.md` (this file)\n"
    md_content += "  - `secrets-report.json` (machine-readable)\n"

    return md_content, total


def write_report(report_path, content):
    """Write markdown report to file."""
    try:
        with open(report_path, "w") as f:
            f.write(content)
    except Exception as e:
        raise RuntimeError(f"Failed to write markdown report: {e}") from e


def main():
    """Generate markdown report from Gitleaks JSON output."""
    os.makedirs(".secrets-reports", exist_ok=True)

    json_path = ".secrets-reports/secrets-report.json"
    report_path = ".secrets-reports/secrets-report.md"

    findings = read_json_report(json_path)
    report_content, finding_count = build_markdown_report(findings)
    write_report(report_path, report_content)

    print("✅ Markdown report generated successfully")
    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception as e:
        print(f"❌ Error generating markdown report: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
