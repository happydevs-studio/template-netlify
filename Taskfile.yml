version: '3'

tasks:
  hygiene:complexity:
    desc: Analyze code complexity using Lizard
    summary: |
      Performs code complexity analysis on the codebase using Lizard.
      Generates both text and CSV reports with configurable thresholds.
      
      Usage:
        task hygiene:complexity           # Run analysis
        task hygiene:complexity -- -v     # Verbose output
    cmds:
      - task: hygiene:complexity:check-tool
      - task: hygiene:complexity:analyze
      - task: hygiene:complexity:report
    silent: false

  hygiene:complexity:check-tool:
    desc: Check if Lizard is installed, install if necessary
    internal: true
    cmds:
      - |
        if ! command -v lizard &> /dev/null; then
          echo "üì¶ Installing Lizard..."
          
          INSTALL_SUCCESS=0
          
          if command -v pip3 &> /dev/null; then
            echo "Trying pip3..."
            if pip3 install --user lizard; then
              INSTALL_SUCCESS=1
            fi
          elif command -v pip &> /dev/null; then
            echo "Trying pip..."
            if pip install --user lizard; then
              INSTALL_SUCCESS=1
            fi
          elif command -v sudo &> /dev/null && command -v apt-get &> /dev/null; then
            echo "Trying apt-get..."
            if sudo apt-get update && sudo apt-get install -y python3-pip && pip3 install --user lizard; then
              INSTALL_SUCCESS=1
            fi
          elif command -v brew &> /dev/null; then
            echo "Trying brew..."
            if brew install lizard; then
              INSTALL_SUCCESS=1
            fi
          fi
          
          if [ $INSTALL_SUCCESS -eq 0 ]; then
            echo "‚ùå Failed to install Lizard with any available package manager"
            echo "Please install Lizard manually:"
            echo "  - pip install lizard"
            echo "  - brew install lizard"
            echo "  - https://github.com/terryyin/lizard"
            exit 1
          fi
        fi
        
        # Verify installation succeeded
        if ! command -v lizard &> /dev/null; then
          echo "‚ùå Lizard installed but not found in PATH"
          exit 1
        fi
        
        LIZARD_VERSION=$(lizard --version 2>&1)
        echo "‚úÖ Lizard $LIZARD_VERSION"
    silent: false

  hygiene:complexity:analyze:
    desc: Run Lizard analysis and generate reports
    internal: true
    dir: .
    cmds:
      - |
        echo ""
        echo "üîç Analyzing code complexity..."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        # Create reports directory
        mkdir -p .complexity-reports
        
        # Run lizard and generate text report (intermediate)
        lizard . \
          -x "tests/*" \
          -x ".github/*" \
          -x "node_modules/*" \
          -x ".git/*" \
          -o ".complexity-reports/complexity-report-raw.txt" \
          || true
        
        # Generate CSV report for structured data
        lizard . \
          -x "tests/*" \
          -x ".github/*" \
          -x "node_modules/*" \
          -x ".git/*" \
          --csv > ".complexity-reports/complexity-report.csv" \
          || true
        
        # Convert to markdown using Python
        python3 .scripts/generate-complexity-md.py
        
        echo "‚úÖ Analysis complete"
    silent: false

  hygiene:complexity:report:
    desc: Display formatted complexity report
    internal: true
    cmds:
      - |
        echo ""
        echo "üìä COMPLEXITY REPORT"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        if [ ! -f .complexity-reports/complexity-report.md ]; then
          echo "‚ùå Complexity report not generated!"
          echo "This indicates an error in the analysis step. Check the logs above."
          exit 1
        fi
        
        cat .complexity-reports/complexity-report.md
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        echo "üìÅ Reports saved to: .complexity-reports/"
        echo "   ‚Ä¢ complexity-report.md (human-readable)"
        echo "   ‚Ä¢ complexity-report.csv (machine-readable)"
        echo ""
        
        # Check for high complexity issues (CCN in column 2, indexed as $2)
        if [ -f .complexity-reports/complexity-report.csv ]; then
          HIGH_COMPLEXITY=$(awk -F',' '$2 > 10' .complexity-reports/complexity-report.csv | wc -l)
          if [ "$HIGH_COMPLEXITY" -gt 0 ]; then
            echo "‚ö†Ô∏è  Found $HIGH_COMPLEXITY item(s) with cyclomatic complexity > 10"
            echo ""
          else
            echo "‚úÖ No high-complexity items found (all CCN ‚â§ 10)"
            echo ""
          fi
        fi
    silent: false

  security:
    internal: true
    desc: Run all security checks (SAST, vulnerabilities, DAST, secrets)
    summary: |
      Runs the full security suite: SAST (Semgrep), vulnerability scanning (Trivy),
      DAST (OWASP ZAP), and secrets detection (Gitleaks).

      Usage:
        task security                           # Run all checks
        task sast                               # SAST only
        task vulnerability:all                  # Vulnerability scan only
        task dast -- http://localhost:8080      # DAST only
        task secrets                            # Secrets detection only
    cmds:
      - task: sast
      - task: vulnerability:all
      - task: dast
      - task: secrets
    silent: false

  sast:
    internal: true
    desc: Run static application security testing using Semgrep
    summary: |
      Performs SAST on the codebase using Semgrep.
      Generates both JSON and Markdown reports.

      Usage:
        task sast           # Run analysis
    cmds:
      - task: sast:check-tool
      - task: sast:analyze
      - task: sast:report
    silent: false

  sast:check-tool:
    desc: Check if Semgrep is installed, install if necessary
    internal: true
    cmds:
      - |
        if ! command -v semgrep &> /dev/null; then
          echo "üì¶ Installing Semgrep..."
          
          INSTALL_SUCCESS=0
          
          if command -v pip3 &> /dev/null; then
            echo "Trying pip3..."
            if pip3 install --user semgrep; then
              INSTALL_SUCCESS=1
            fi
          elif command -v pip &> /dev/null; then
            echo "Trying pip..."
            if pip install --user semgrep; then
              INSTALL_SUCCESS=1
            fi
          fi
          
          if [ $INSTALL_SUCCESS -eq 0 ]; then
            echo "‚ùå Failed to install Semgrep"
            echo "Please install Semgrep manually:"
            echo "  - pip install semgrep"
            echo "  - https://semgrep.dev/docs/getting-started/"
            exit 1
          fi
        fi
        
        if ! command -v semgrep &> /dev/null; then
          echo "‚ùå Semgrep installed but not found in PATH"
          exit 1
        fi
        
        SEMGREP_VERSION=$(semgrep --version 2>&1)
        echo "‚úÖ Semgrep $SEMGREP_VERSION"
    silent: false

  sast:analyze:
    desc: Run Semgrep SAST analysis and generate reports
    internal: true
    dir: .
    cmds:
      - |
        echo ""
        echo "üîç Running SAST analysis..."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        mkdir -p .sast-reports
        
        semgrep \
          --config=auto \
          --json \
          --output=".sast-reports/sast-report.json" \
          --exclude="node_modules" \
          --exclude=".git" \
          . \
          || true
        
        python3 .scripts/generate-sast-md.py
        
        echo "‚úÖ Analysis complete"
    silent: false

  sast:report:
    desc: Display formatted SAST report
    internal: true
    cmds:
      - |
        echo ""
        echo "üîç SAST REPORT"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        if [ ! -f .sast-reports/sast-report.md ]; then
          echo "‚ùå SAST report not generated!"
          exit 1
        fi
        
        cat .sast-reports/sast-report.md
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        echo "üìÅ Reports saved to: .sast-reports/"
        echo "   ‚Ä¢ sast-report.md (human-readable)"
        echo "   ‚Ä¢ sast-report.json (machine-readable)"
        echo ""
        
        if [ -f .sast-reports/sast-report.json ]; then
          ERROR_COUNT=$(python3 -c "
        import json, sys
        with open('.sast-reports/sast-report.json') as f:
          data = json.load(f)
        errors = [r for r in data.get('results', []) if r.get('extra', {}).get('severity', '').upper() == 'ERROR']
        print(len(errors))
        " 2>/dev/null || echo "0")
          if [ "$ERROR_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è  Found $ERROR_COUNT error-severity finding(s)"
            echo ""
          else
            echo "‚úÖ No error-severity findings detected"
            echo ""
          fi
        fi
    silent: false

  vulnerability:all:
    internal: true
    desc: Run vulnerability scanning using Trivy
    summary: |
      Scans project dependencies for known CVEs using Trivy.
      Generates both JSON and Markdown reports.

      Usage:
        task vulnerability:all           # Run scan
    cmds:
      - task: vulnerability:all:check-tool
      - task: vulnerability:all:analyze
      - task: vulnerability:all:report
    silent: false

  vulnerability:all:check-tool:
    desc: Check if Trivy is installed, install if necessary
    internal: true
    cmds:
      - |
        if ! command -v trivy &> /dev/null; then
          echo "üì¶ Installing Trivy..."
          
          INSTALL_SUCCESS=0
          
          if command -v curl &> /dev/null; then
            echo "Trying install script..."
            if curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b ~/.local/bin; then
              export PATH="$PATH:$HOME/.local/bin"
              INSTALL_SUCCESS=1
            fi
          fi
          
          if [ $INSTALL_SUCCESS -eq 0 ]; then
            echo "‚ùå Failed to install Trivy"
            echo "Please install Trivy manually:"
            echo "  - https://trivy.dev/latest/getting-started/installation/"
            exit 1
          fi
        fi
        
        if ! command -v trivy &> /dev/null; then
          echo "‚ùå Trivy installed but not found in PATH"
          exit 1
        fi
        
        TRIVY_VERSION=$(trivy --version 2>&1 | head -1)
        echo "‚úÖ $TRIVY_VERSION"
    silent: false

  vulnerability:all:analyze:
    desc: Run Trivy dependency scan and generate reports
    internal: true
    dir: .
    cmds:
      - |
        echo ""
        echo "üîç Scanning dependencies for vulnerabilities..."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        mkdir -p .dependencies-reports
        
        trivy fs \
          --format json \
          --output ".dependencies-reports/dependencies-report.json" \
          --skip-dirs node_modules \
          --skip-dirs .git \
          . \
          || true
        
        python3 .scripts/generate-dependencies-md.py
        
        echo "‚úÖ Scan complete"
    silent: false

  vulnerability:all:report:
    desc: Display formatted dependency vulnerability report
    internal: true
    cmds:
      - |
        echo ""
        echo "üì¶ DEPENDENCY VULNERABILITY REPORT"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        if [ ! -f .dependencies-reports/dependencies-report.md ]; then
          echo "‚ùå Dependency report not generated!"
          exit 1
        fi
        
        cat .dependencies-reports/dependencies-report.md
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        echo "üìÅ Reports saved to: .dependencies-reports/"
        echo "   ‚Ä¢ dependencies-report.md (human-readable)"
        echo "   ‚Ä¢ dependencies-report.json (machine-readable)"
        echo ""
        
        if [ -f .dependencies-reports/dependencies-report.json ]; then
          VULN_COUNT=$(python3 -c "
        import json, sys
        with open('.dependencies-reports/dependencies-report.json') as f:
          data = json.load(f)
        count = 0
        for r in data.get('Results', []):
          for v in r.get('Vulnerabilities', []):
            if v.get('Severity', '').upper() in ('CRITICAL', 'HIGH'):
              count += 1
        print(count)
        " 2>/dev/null || echo "0")
          if [ "$VULN_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è  Found $VULN_COUNT CRITICAL/HIGH vulnerability(ies)"
            echo ""
          else
            echo "‚úÖ No CRITICAL/HIGH vulnerabilities detected"
            echo ""
          fi
        fi
    silent: false

  dast:
    internal: true
    desc: Run dynamic application security testing using OWASP ZAP
    summary: |
      Performs DAST against a running site using OWASP ZAP (requires Docker).
      Generates both JSON and Markdown reports.

      Usage:
        task start &                           # Start site first
        task dast -- http://localhost:8080     # Then run DAST
    vars:
      TARGET: '{{default "http://localhost:8080" .CLI_ARGS}}'
    cmds:
      - task: dast:check-tool
      - task: dast:analyze
        vars:
          TARGET: '{{.TARGET}}'
      - task: dast:report
    silent: false

  dast:check-tool:
    desc: Check if Docker (for ZAP) is available
    internal: true
    cmds:
      - |
        if ! command -v docker &> /dev/null; then
          echo "‚ùå Docker is required to run OWASP ZAP"
          echo "Please install Docker: https://docs.docker.com/get-docker/"
          exit 1
        fi
        
        DOCKER_VERSION=$(docker --version 2>&1)
        echo "‚úÖ $DOCKER_VERSION"
    silent: false

  dast:analyze:
    desc: Run OWASP ZAP baseline scan and generate reports
    internal: true
    dir: .
    vars:
      TARGET: '{{default "http://localhost:8080" .TARGET}}'
    cmds:
      - |
        echo ""
        echo "üåê Running DAST analysis against {{.TARGET}}..."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        mkdir -p .dast-reports
        chmod 777 .dast-reports
        
        # Check if target is localhost and if server needs to be started  
        TARGET="{{.TARGET}}"
        if [[ "$TARGET" == *"localhost"* ]] || [[ "$TARGET" == "http://127.0.0.1"* ]]; then
          echo "üöÄ Starting local development server..."
          node server.js > /dev/null 2>&1 &
          SERVER_PID=$!
          
          # Wait for server to be ready
          echo "‚è≥ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -s http://localhost:8080 > /dev/null 2>&1; then
              echo "‚úÖ Server is ready"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "‚ùå Server failed to start within 30 seconds"
              kill $SERVER_PID 2>/dev/null || true
              exit 1
            fi
            sleep 1
          done
          
          trap "kill $SERVER_PID 2>/dev/null || true" EXIT
          # Replace localhost with Docker gateway IP for access from container
          TARGET="http://172.17.0.1:8080"
          echo "üìç Using Docker-compatible target: $TARGET"
        fi
        
        docker run --rm \
          -v "$(pwd)/.dast-reports:/zap/wrk/:rw" \
          ghcr.io/zaproxy/zaproxy:stable \
          zap-baseline.py \
          -t "$TARGET" \
          -J "dast-report.json" \
          -I \
          || true
        
        python3 .scripts/generate-dast-md.py
        
        echo "‚úÖ Analysis complete"
    silent: false

  dast:report:
    desc: Display formatted DAST report
    internal: true
    cmds:
      - |
        echo ""
        echo "üåê DAST REPORT"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        if [ ! -f .dast-reports/dast-report.md ]; then
          echo "‚ùå DAST report not generated!"
          exit 1
        fi
        
        cat .dast-reports/dast-report.md
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        echo "üìÅ Reports saved to: .dast-reports/"
        echo "   ‚Ä¢ dast-report.md (human-readable)"
        echo "   ‚Ä¢ dast-report.json (machine-readable)"
        echo ""
        
        if [ -f .dast-reports/dast-report.json ]; then
          ALERT_COUNT=$(python3 -c "
        import json, sys
        with open('.dast-reports/dast-report.json') as f:
          data = json.load(f)
        count = 0
        for site in data.get('site', []):
          for alert in site.get('alerts', []):
            if int(alert.get('riskcode', 0)) >= 2:
              count += 1
        print(count)
        " 2>/dev/null || echo "0")
          if [ "$ALERT_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è  Found $ALERT_COUNT medium/high alert(s)"
            echo ""
          else
            echo "‚úÖ No medium/high alerts detected"
            echo ""
          fi
        fi
    silent: false

  secrets:
    internal: true
    desc: Run secrets detection using Gitleaks
    summary: |
      Scans the codebase and git history for hardcoded credentials using Gitleaks.
      Generates both JSON and Markdown reports.

      Usage:
        task secrets           # Run detection
    cmds:
      - task: secrets:check-tool
      - task: secrets:analyze
      - task: secrets:report
    silent: false

  secrets:check-tool:
    desc: Check if Gitleaks is installed, install if necessary
    internal: true
    cmds:
      - |
        if ! command -v gitleaks &> /dev/null; then
          echo "üì¶ Installing Gitleaks..."
          
          INSTALL_SUCCESS=0
          
          if command -v curl &> /dev/null; then
            echo "Trying GitHub releases..."
            
            # Detect OS and architecture
            OS=$(uname -s | tr '[:upper:]' '[:lower:]')
            ARCH=$(uname -m)
            case "$ARCH" in
              x86_64) ARCH="x64" ;;
              aarch64|arm64) ARCH="arm64" ;;
              *) ARCH="x64" ;;
            esac
            case "$OS" in
              darwin) OS="darwin" ;;
              linux)  OS="linux" ;;
              *)      OS="linux" ;;
            esac
            
            LATEST=$(curl -s https://api.github.com/repos/gitleaks/gitleaks/releases/latest | grep '"tag_name"' | sed 's/.*"v\([^"]*\)".*/\1/')
            DOWNLOAD_URL="https://github.com/gitleaks/gitleaks/releases/latest/download/gitleaks_${LATEST}_${OS}_${ARCH}.tar.gz"
            
            mkdir -p ~/.local/bin
            if curl -sSfL "$DOWNLOAD_URL" | tar -xz -C ~/.local/bin gitleaks 2>/dev/null; then
              export PATH="$PATH:$HOME/.local/bin"
              INSTALL_SUCCESS=1
            fi
          fi
          
          if [ $INSTALL_SUCCESS -eq 0 ]; then
            echo "‚ùå Failed to install Gitleaks"
            echo "Please install Gitleaks manually:"
            echo "  - https://gitleaks.io/"
            exit 1
          fi
        fi
        
        if ! command -v gitleaks &> /dev/null; then
          echo "‚ùå Gitleaks installed but not found in PATH"
          exit 1
        fi
        
        GITLEAKS_VERSION=$(gitleaks version 2>&1)
        echo "‚úÖ Gitleaks $GITLEAKS_VERSION"
    silent: false

  secrets:analyze:
    desc: Run Gitleaks secrets detection and generate reports
    internal: true
    dir: .
    cmds:
      - |
        echo ""
        echo "üîë Running secrets detection..."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        mkdir -p .secrets-reports
        
        # Run gitleaks against full git history; exit code 1 means secrets found, which is expected
        gitleaks detect \
          --source=. \
          --report-format=json \
          --report-path=".secrets-reports/secrets-report.json" \
          || true
        
        python3 .scripts/generate-secrets-md.py
        
        echo "‚úÖ Detection complete"
    silent: false

  secrets:report:
    desc: Display formatted secrets detection report
    internal: true
    cmds:
      - |
        echo ""
        echo "üîë SECRETS DETECTION REPORT"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        
        if [ ! -f .secrets-reports/secrets-report.md ]; then
          echo "‚ùå Secrets report not generated!"
          exit 1
        fi
        
        cat .secrets-reports/secrets-report.md
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo ""
        echo "üìÅ Reports saved to: .secrets-reports/"
        echo "   ‚Ä¢ secrets-report.md (human-readable)"
        echo "   ‚Ä¢ secrets-report.json (machine-readable)"
        echo ""
        
        if [ -f .secrets-reports/secrets-report.json ]; then
          SECRET_COUNT=$(python3 -c "
        import json, sys
        with open('.secrets-reports/secrets-report.json') as f:
          content = f.read().strip()
        if not content or content == 'null':
          print(0)
        else:
          data = json.loads(content)
          print(len(data) if isinstance(data, list) else 0)
        " 2>/dev/null || echo "0")
          if [ "$SECRET_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è  Found $SECRET_COUNT secret(s) ‚Äî revoke and remove immediately"
            echo ""
          else
            echo "‚úÖ No secrets detected"
            echo ""
          fi
        fi
    silent: false

  contributing:setup:
    desc: Install project dependencies
    cmds:
      - npm install

  contributing:build:
    desc: Build the project (if a build script is defined)
    cmds:
      - |
        if node -e "const p=require('./package.json'); process.exit(p.scripts && p.scripts.build ? 0 : 1)"; then
          npm run build {{.CLI_ARGS}}
        else
          echo "‚ÑπÔ∏è  No build script defined in package.json; nothing to build for this static project."
        fi

  contributing:lint:
    desc: Run lint checks
    cmds:
      - |
        if node -e "const p=require('./package.json'); process.exit(p.scripts && p.scripts.lint ? 0 : 1)"; then
          npm run lint {{.CLI_ARGS}}
        else
          files="docs/**/*.md"
          if [ -f CONTRIBUTING.md ]; then
            files="$files CONTRIBUTING.md"
          fi
          npx markdownlint $files
        fi

  contributing:run:
    desc: Run local development server
    cmds:
      - node server.js

  contributing:test:
    desc: Run Playwright tests
    cmds:
      - npx playwright test {{.CLI_ARGS}}

  contributing:test:headed:
    desc: Run Playwright tests with headed browser
    cmds:
      - npx playwright test --headed {{.CLI_ARGS}}

  contributing:test:complexity:
    desc: Run complexity report generation tests
    cmds:
      - python3 tests/generate_complexity_report.test.py

  contributing:test:security:
    desc: Run all security report generation tests
    cmds:
      - task: contributing:test:sast
      - task: contributing:test:dependencies
      - task: contributing:test:dast
      - task: contributing:test:secrets

  contributing:test:sast:
    desc: Run SAST report generation tests
    cmds:
      - python3 tests/generate_sast_report.test.py

  contributing:test:vulnerability:
    desc: Run vulnerability report generation tests
    cmds:
      - python3 tests/generate_dependencies_report.test.py

  contributing:test:dast:
    desc: Run DAST report generation tests
    cmds:
      - python3 tests/generate_dast_report.test.py

  contributing:test:secrets:
    desc: Run secrets detection report generation tests
    cmds:
      - python3 tests/generate_secrets_report.test.py

  contributing:start:
    desc: Start local development server
    cmds:
      - task: contributing:run

  # Hygiene tasks
  hygiene:lint:
    desc: Lint documentation markdown files
    cmds:
      - npx markdownlint "docs/**/*.md"

  hygiene:structure:
    desc: Verify documentation index exists
    cmds:
      - |
        if [ ! -f docs/index.md ]; then
          echo "‚ùå docs/index.md not found"
          exit 1
        fi
        echo "‚úÖ docs/index.md found"

  hygiene:size:
    desc: Check for oversized markdown files in docs
    cmds:
      - |
        python3 - <<'PY'
        import glob
        import pathlib
        import re
        import sys

        max_words = 2500
        violations = []

        for path in glob.glob('docs/**/*.md', recursive=True):
          text = pathlib.Path(path).read_text(encoding='utf-8')
          words = len(re.findall(r"\\b\\w+\\b", text))
          if words > max_words:
            violations.append((path, words))

        if violations:
          print(f"‚ùå Found {len(violations)} oversized doc file(s) (>{max_words} words):")
          for path, words in violations:
            print(f"  - {path}: {words} words")
          sys.exit(1)

        print("‚úÖ No oversized markdown files found in docs")
        PY

  hygiene:docs-size:
    desc: Monitor documentation size and check against thresholds
    summary: |
      Analyzes documentation size against configured thresholds:
      - Total documentation size (max 150 KB)
      - Individual file sizes (max 20 KB)
      - Number of documentation files (max 15)
      
      Generates a detailed report in .docs-reports/docs-size-report.md
      
      Usage:
        task hygiene:docs-size    # Run size monitoring
    cmds:
      - bash .scripts/check-docs-size.sh

  hygiene:test:
    desc: Run all hygiene checks for code and documentation
    cmds:
      - task: hygiene:lint
      - task: hygiene:structure
      - task: hygiene:size
      - task: hygiene:docs-size
      - task: hygiene:complexity

  # Security tasks
  security:scan:
    desc: Run full security scan suite
    cmds:
      - task: security

  security:sast:
    desc: Run static application security testing
    cmds:
      - task: sast

  security:vulnerability:all:
    desc: Run vulnerability scanning
    cmds:
      - task: dependencies

  security:dast:
    desc: Run dynamic application security testing
    cmds:
      - task: dast

  security:secrets:
    desc: Run secrets detection
    cmds:
      - task: secrets

  # Decisions tasks
  decisions:validate:
    desc: Validate decisions documentation baseline
    cmds:
      - |
        if [ ! -f docs/decisions/DECISIONS.md ]; then
          echo "‚ùå docs/decisions/DECISIONS.md not found"
          exit 1
        fi
        if [ ! -f docs/decisions/DECISION_TEMPLATE.md ]; then
          echo "‚ùå docs/decisions/DECISION_TEMPLATE.md not found"
          exit 1
        fi
        if ! grep -q "| Date | Decision | Status | Rationale | Notes |" docs/decisions/DECISIONS.md; then
          echo "‚ùå docs/decisions/DECISIONS.md is missing the decisions table header"
          exit 1
        fi
        echo "‚úÖ Decisions documentation baseline is valid"

  decisions:new:
    desc: Create a new decision note from template (use SLUG=<name>)
    vars:
      DATE:
        sh: date +%F
    cmds:
      - |
        if [ -z "{{.SLUG}}" ]; then
          echo "‚ùå Missing SLUG. Usage: task decisions:new SLUG=<decision-name>"
          exit 1
        fi
        target="docs/decisions/{{.DATE}}-{{.SLUG}}.md"
        if [ -f "$target" ]; then
          echo "‚ùå $target already exists"
          exit 1
        fi
        cp docs/decisions/DECISION_TEMPLATE.md "$target"
        echo "‚úÖ Created $target"
